#!/bin/bash
#
#   Wrath, version 0.3.0. Copyright 2023 Jon Pretty, Propensive OÜ.
#
#   The primary distribution site is: https://propensive.com/
#
#   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
#   file except in compliance with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software distributed under the
#   License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
#   either express or implied. See the License for the specific language governing permissions
#   and limitations under the License.
#

declare -g -A include built parsed hashes lib sources mainClass jars plugin repoSeen building download
declare -g run fetch scala scalac compiler repl esc overrideMain execClass defaultDir workDir
declare -g project module buildFile
declare -i columns

# start codl.sh
declare -A nodes childNodes nodeTypes identifier values
declare -a focus
focus=("")
shopt -s extglob

refocus() {
  local -i level difference depth
  local -a nodeArgs
  local node nodeType address parent
  level=$1
  nodeId="$2"
  file="$3"
  nodeType="$4"
  nodeArgs=("${@:4}")
  depth=${#focus[@]}
  difference=$((depth-level))
  
  while [ $difference -gt 2 ]
  do
    unset 'focus[-1]'
    depth=${#focus[@]}
    difference=$((depth-level))
  done
  
  if [ $difference = 2 ]
  then
    unset 'focus[-1]'
    difference=$((difference-1))
  fi
  if [ $difference = 1 ]
  then focus+=("$nodeId")
  fi
  
  printf -v address ".%s" "${focus[@]}"
  parent="${address%.*}"
  address="${address:2}"
  parent="${parent:2}"
  nodeTypes["$file:$address"]="${nodeType}"
  
  if [ "${values["$file:$address"]}" = "" ]
  then values["$file:$address"]="${nodeArgs[*]:1}"
  else values["$file:$address"]+=" ${nodeArgs[*]:1}"
  fi

  if [ "${childNodes["$file:$parent"]}" = "" ]
  then childNodes["$file:$parent"]="$file:$address"
  else childNodes["$file:$parent"]+=" $file:$address"
  fi
}

parseLine() {
  local -i level abort lineNo
  local -a atoms
  local line IFS id file
  file="$1"
  line="$2"
  level=0
  abort=0

  while [ $abort = 0 ]
  do
    case "$line" in
      *( )#*|*( ))
        abort=1
        lineNo=$((lineNo+1))
        ;;
      '  '*)
        level=$((level+1))
        line="${line:2}"
        lineNo=$((lineNo+1))
        ;;
      *)
        read -ra atoms <<< "$line"
        nonEmpty "${identifier[${atoms[0]}]}" "Unrecognized identifier: ${atoms[0]} in $file line $lineNo"
        id="${atoms[${identifier[${atoms[0]}]}]}"
        nonEmpty "$id" "Unrecognized atom: '${atoms[0]}'"
        refocus $level "$id" "$file" "${atoms[0]}" "${atoms[@]:1}"
        abort=1
        lineNo=$((lineNo+1))
        ;;
    esac
  done
}

parseCodl() {
  local file IFS
  file="$1"
  filename="$file"
  while IFS=$'\n' read -r line
  do parseLine "$filename" "$line"
  done < "$file"
}

childPaths() {
  local filter node IFS
  local -a nodes
  IFS=$' '
  node="$1"
  filter="$2"
  read -ra nodes <<< "${childNodes[$node]}"
  for node in "${nodes[@]}"
  do
    if [ "$filter" = "" ]
    then printf "%s\n" "$node"
    elif [ "$filter" = "${nodeTypes[$node]}" ]
    then printf "%s\n" "$node"
    fi
  done
}

children() {
  local filter node IFS
  local -a nodes
  local -i prefix
  IFS=$' '
  node="$1"
  prefix="${#node}"
  filter="$2"
  
  if [ "${node:0-1}" != ":" ]
  then prefix=$((prefix+1))
  fi
  
  read -ra nodes <<< "${childNodes[$node]}"
  for node in "${nodes[@]}"
  do
    if [ "$filter" = "" ]
    then printf "%s\n" "${node:$prefix}"
    elif [ "$filter" = "${nodeTypes[$node]}" ]
    then printf "%s\n" "${node:$prefix}"
    fi
  done
}

nonEmpty() {
  if [ "$1" = "" ]
  then
    printf "%s\n" "$2"
    exit 1
  fi
}

values() {
  local address
  local -a data
  address="$1"
  nonEmpty "$address" "Cannot access values for empty node"
  read -ra data <<< "${values[$address]}"
  for datum in "${data[@]}"
  do printf "%s\n" "$datum"
  done
}
# end codl.sh

esc=$'\e'
columns=${COLUMNS:-116}
configFile="${XDG_CONFIG_HOME:-$HOME/.config}/wrath.conf"
buildFile="fury"
fetch=0

nonempty() {
  if [ "$2" = "" ]
  then
    echo "The option $1 requires a parameter."
    exit 1
  fi
}

showHelp() {
  cat << EOF
Usage: wrath [options]
Builds a project with Wrath.

Options:
  -c, --clean              clean the target project
  -C, --deep-clean         clean all targets
  -d, --default <dir>      look inside directory <dir> for dependencies
  -f, --fetch              automatically fetch missing dependencies
  -F, --fetch-all          automatically fetch missing dependencies and compiler
  -h, --help               show this help message
  -j, --jdk <path>         use the JDK with home directory at <path>
  -r, --repl               start the REPL
  -t, --target <target>    target to compile
  -x, --exec <class>       run the main class <class>

Examples:
  wrath -t rudiments/core
  wrath -C -t rudiments/core -F

© Copyright 2023 Jon Pretty & Propensive OÜ
EOF
  exit 0
}

fetchLibs() {
  local id IFS
  local -a libs
  IFS=" "
  id="$1"
  read -ra libs <<< "${jars[$id]}"

  for url in "${libs[@]}"
  do
    if [ ! -f ".wrath/lib/$url.jar" ]
    then
      message "$id" "Downloading $url"
      download "${download[$url]}" "${url}.jar"
    fi
  done
}

download() {
  local filename url
  url="$1"
  filename="$2"
  wget -q -O .wrath/lib/"$filename" "$url"
}

fetchRepo() {
  local repo dest
  repo="$1"
  dest="$2"
  if [ ! -d "$dest" ]
  then
    rmessage "$repo" "Cloning Git repository"
    git clone -q https://github.com/"$repo" "$dest"
  fi
}

clean() {
  case "$clean" in
    1)
      message "$project"/"$module" "Cleaning"
      rm -rf .wrath/bin/"$target" .wrath/cache/"$target" .wrath/log/"$target"
      ;;
    2)
      gmessage "Cleaning all modules"
      rm -rf .wrath/bin .wrath/cache .wrath/log .wrath/plugin
      ;;
  esac
}

checkCompiler() {
  if [ -d scala ]
  then compiler="$(realpath scala)"
  else
    if [ -d "$defaultDir"/scala ]
    then compiler="$(realpath "$defaultDir"/scala)"
    elif [ "$fetch" = 2 ]
    then
      compiler="$(realpath scala)"
      gmessage "Fetching Scala compiler"
      fetchRepo lampepfl/dotty dotty && mv dotty scala
      gmessage "Building Scala compiler"
      mkdir -p .wrath/log
      "$compiler"/bin/scalac -version > .wrath/log/scala.log 2>&1
      gmessage "Finished building Scala compiler"
      gmessage "$(scala/bin/scala -version 2>&1)"
    else
      gmessage "Scala compiler not found."
      gmessage "Try again with -F or create a symlink to a clone of the lampepfl/dotty repository."
      exit 1
    fi
  fi
  scala="$compiler"/bin/scala
  scalac="$compiler"/bin/scalac
}

mkdirs() {
  mkdir -p .wrath/bin dist .wrath/cache .wrath/log .wrath/plugin .wrath/lib
}

setChecksum() {
  local dir
  dir="$1"
  if [ "${hashes[$dir]}" = "" ]
  then
    if compgen -G "$dir"/*.scala > /dev/null
    then hashes[$dir]="$(cat "$dir"/*.scala | md5sum | cut -d' ' -f1)"
    else hashes[$dir]="0"
    fi
  fi
}

package() {
  local dir jarFile
  local -a args
  
  jarFile="$1"
  dir="$2"

  for include in "$dir"/*
  do
    find "$include" -print0 | while IFS= read -r -d '' item
    do touch -d 2000-01-01 "$item"
    done
    args+=(-C "${include%/*}" "${include##*/}")
  done
  jar cMf "${jarFile}" "${args[@]}"
}

readConfig() {
  if [ "$defaultDir" = "" ]
  then
    if [ -e "$configFile" ]
    then defaultDir="$(cat "$configFile")"
    else defaultDir="$workDir"
    fi
  fi
}

readCodl() {
  local brepo file ref IFS project module repoDir lib
  local -i isMain
  local -a libDetails
  IFS=$'\n'
  brepo="$1"
  file="$2"
  isMain="$3"
  if [ ! "${parsed[$file]}" = "1" ]
  then
    if [ ! "$isMain" = "1" ]
    then rmessage "$brepo" "Reading build file"
    fi
    parsed[$file]="1"
    parseCodl "$file"

    if [ "$isMain" = "1" ]
    then target="$(values "$file:target")"
    fi

    for repo in $(children "$file:" repo)
    do
      if [ ! "${repoSeen[$repo]}" = "1" ]
      then
        repoDir="$defaultDir/${repo#*/}"
	if [ ! -d "$repoDir" ]
	then 
          if [ "$fetch" -ge "1" ]
          then fetchRepo "$repo" "$repoDir"
	  else
	    rmessage "$repo" "Repository not found"
	    rmessage "$repo" "Run wrath with -f to fetch missing repositories, or create a symlink to $repo in the current directory"
	    exit 1
          fi
	else
          repoSeen["$repo"]="1"
          readCodl "$repo" "$repoDir"/"$buildFile"
	fi
      fi
    done

    for project in $(children "$file:" project)
    do
      for module in $(children "$file:$project" module)
      do
        for lib in $(children "$file:$project.$module" lib)
	do
          IFS=$' '
	  libDetails=( ${values["$file:$project.$module.$lib"]} )
	  download["${libDetails[0]}"]="${libDetails[1]}"
	  jars["$project/$module"]+="${libDetails[0]} "
	done
        mainClass["$project/$module"]="$(values "$file:$project.$module.main")"
        sources["$project/$module"]="$(values "$file:$project.$module.sources")"
        include["$project/$module"]="$(values "$file:$project.$module.include")"
        
        if [ "$(values "$file:$project.$module.plugin")" = "yes" ]
        then plugin["$project/$module"]="1"
        fi

      done
    done
  fi
}

classpath() {
  local IFS id
  local -a acc dependencies dedup
  id="$1"
  IFS=" "
  
  if [ "${lib[$id]}" = "" ]
  then
    read -ra libs <<< "${jars[$id]}"
    for jar in "${libs[@]}"
    do acc+=(.wrath/lib/"${jar##*/}.jar")
    done
    
    read -ra dependencies <<< "${include[$id]}"
    for ref in "${dependencies[@]}"
    do classpath "$ref"
    done
    
    for ref in "${dependencies[@]}"
    do
      acc+=(dist/"${ref//\//-}".jar)
      acc+=("${lib[$ref]}")
    done

    dedup="$(echo "${acc[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')"
    lib[$id]="$dedup"
  fi
}

build() {
  local IFS id bproject bmodule root srcDir chksum
  
  id="$1"
  bproject="${id%%/*}"
  bmodule="${id##*/}"
  
  if [ "$bproject" = "$project" ]
  then root="$(realpath .)"
  else root="$(realpath "$defaultDir/$bproject")"
  fi

  IFS=' '

  fetchLibs "$id"

  if [ ! "${building[$id]}" = "1" ]
  then
    read -ra dependencies <<< "${include[$id]}"
    building[$id]="1"
    for ref in "${dependencies[@]}"
    do build "$ref"
    done
    
    
    srcDir="$root/${sources[$bproject/$bmodule]}"
    chksum="$(cat .wrath/cache/"$id" 2>/dev/null)"
    setChecksum "${srcDir}"
    if [ ! "$chksum" = "${hashes[$srcDir]}" ]
    then
      mkdir -p .wrath/bin/"$bproject"/"$bmodule"
      if [ -d "$root/res" ]
      then
        for res in "$root"/res/*
        do cp -r "$res" .wrath/bin/"$bproject"/"$bmodule"/
        done
      fi
      classpath "$id"
      classpath="${lib[$id]// /:}"
      rm -f .wrath/log/"$bproject"/"$bmodule".log
      compile "$bproject" "$bmodule" "$classpath" "$root"
  
      if [ "${plugin[$bproject/$bmodule]}" = "1" ]
      then
        message "$bproject"/"$bmodule" "Installing plugin"
        cp dist/"$bproject"-"$bmodule".jar .wrath/plugin/"$bproject"-"$bmodule".jar
      fi
    fi
  fi
}

compile() {
  local classpath bproject bmodule root srcDir
  local -i pageWidth
  local -a opts
  bproject="$1"
  bmodule="$2"
  classpath="$3"
  pageWidth=$((columns - 21))
  root="$4"
  srcDir="${sources[$bproject/$bmodule]}"

  opts=(
    -classpath "$classpath"
    -d .wrath/bin/"$bproject"/"$bmodule"
    -Xmax-inlines 64
    -Xpluginsdir .wrath/plugin
    -feature
    -pagewidth "$pageWidth"
    -J-Xss1536K
    -J--enable-preview
    -new-syntax
    -source future
    -Wunused:imports
    -Yrequire-targetName
    -Ysafe-init
    -Yexplicit-nulls
    -Ycheck-all-patmat
    -language:experimental.clauseInterleaving
    -language:experimental.fewerBraces
    -language:experimental.erasedDefinitions
    -language:experimental.saferExceptions
    -language:experimental.namedTypeArguments
  )

  rm -f .wrath/log/"$bproject"-"$bmodule".log
  touch .wrath/log/"$bproject"-"$bmodule".log
  if compgen -G "$root"/"$srcDir"/*.scala > /dev/null
  then
    message "$bproject"/"$bmodule" "Compiling..."
    if $scalac "${opts[@]}" "$root"/"$srcDir"/*.scala > .wrath/log/"$bproject"-"$bmodule".log 2>&1
    then
      mkdir -p .wrath/cache/"$bproject"
      echo "${hashes[$root/$srcDir]}" > .wrath/cache/"$id"
      built[$id]="1"
      message "$bproject"/"$bmodule" "Finished compiling"
    
      while read -r line
      do message "$bproject"/"$bmodule" "$line"
      done < .wrath/log/"$bproject"-"$bmodule".log

      package dist/"$bproject"-"$bmodule".jar .wrath/bin/"$bproject"/"$bmodule"
    else
      message "$bproject"/"$bmodule" "Compilation failed"
    
      while read -r line
      do message "$bproject"/"$bmodule" "$line"
      done < .wrath/log/"$bproject"-"$bmodule".log
    
      exit 1
    fi
  fi
}

fail() {
  message "$1"/"$2" "$3"
  exit 1
}

gmessage() {
  local text prefix
  text="$1"
  prefix="${esc}[1;32mwrath${esc}[2;37m:${esc}[0m"
  printf "%48s %s\n" "$prefix" "$text"
}

message() {
  local id bproject bmodule text prefix
  id="$1"
  bproject="${id%%/*}"
  bmodule="${id##*/}"
  text="$2"
  prefix="${esc}[0;36m$bproject${esc}[2;37m/${esc}[1;34m$bmodule${esc}[2;37m:${esc}[0m"
  printf "%62s %s\n" "$prefix" "$text"
}

rmessage() {
  local id bgroup brepo text prefix
  id="$1"
  bgroup="${id%%/*}"
  brepo="${id##*/}"
  text="$2"
  prefix="${esc}[0;31m$bgroup${esc}[2;37m/${esc}[0;35m$brepo${esc}[2;37m:${esc}[0m"
  printf "%62s %s\n" "$prefix" "$text"
}

parseOpts() {
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      -c|--clean)
        clean="1"
        shift 1 ;;
      -C|--deep-clean)
        clean="2"
        shift 1 ;;
      -d|--default)
        nonempty "$@"
        defaultDir="$2"
        shift 2 ;;
      -f|--fetch)
        fetch="1"
        shift 1 ;;
      -F|--fetch-alll)
        fetch="2"
        shift 1 ;;
      -h|--help)
        showHelp
        ;;
      -j|--jdk)
        nonempty "$@"
        export JAVA_HOME="$2"
        shift 2 ;;
      -m|--main)
        nonempty "$@"
	overrideMain="$2"
	shift 2 ;;
      -r|--repl)
        repl="1"
	shift ;;
      -s|--scala)
        nonempty "$@"
        compiler="$2"
        shift 2 ;;
      -t|--target)
        target="$2"
        shift 2 ;;
      -x|--exec)
        run="1"
        shift ;;
      -*)
        gmessage "Unrecognized option: '$1'"
        exit 1 ;;
      *)
        gmessage "Unrecognized parameter: '$1"
        exit 1 ;;
    esac
  done
}

checkTarget() {
  if [[ "$target" = "" ]]
  then
    gmessage "A build target is required"
    exit 1
  fi
}

identifier[project]=1
identifier[repo]=1
identifier[module]=1
identifier[include]=0
identifier[opt]=0
identifier[sources]=0
identifier[compiler]=0
identifier[plugin]=0
identifier[lib]=1
identifier[name]=0
identifier[description]=0
identifier[target]=0
identifier[main]=0

parseOpts "$@"
gmessage "Reading global config"
workDir="$(realpath "$PWD")"
readConfig
gmessage "Starting build"
readCodl "$project/*" "$workDir"/"$buildFile" 1

project="${target%%/*}"
module="${target##*/}"

clean
mkdirs
checkCompiler
build "$target"

wait

if [ "$run" = "1" ]
then
  classpath "$target"
  classpath="${lib[$target]// /:}"
  execClass="${overrideMain:-${mainClass[$target]}}"
  if [ "$execClass" = "" ]
  then fail "$project" "$module" "Main class has not been specified."
  else "$scala" -classpath "${classpath}"dist/"$project"-"$module".jar "$execClass"
  fi
fi

if [ "$repl" = "1" ]
then
  classpath "$target"
  classpath="${lib[$target]// /:}"
  "$scala" -classpath "${classpath}"dist/"$project"-"$module".jar
fi
