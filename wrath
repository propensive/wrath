#!/bin/bash

declare -g -A refs built parsed pids hashes lib
declare -g run fetch scala scalac compiler

compiler="$(realpath scala)"

nonempty() {
  if [ "$2" = "" ]
  then
    echo "The option $1 requires a parameter."
    exit 1
  fi
}

showHelp() {
  cat << EOF
Usage: wrath [options]
Builds a project with Wrath.

Options:
  -c, --clean              clean the target project
  -C, --deep-clean         clean all targets
  -f, --fetch              automatically fetch missing dependencies
  -F, --fetch-all          automatically fetch missing dependencies and compiler
  -g, --group <group>      use the default group <group>
  -h, --help               show this help message
  -j, --jdk <path>         use the JDK with home directory at <path>
  -r, --run <class>        run the main class <class>
  -t, --target <target>    target to compile

Examples:
  wrath -t rudiments/core
  wrath -C -g propensive -t rudiments/core -F

© Copyright 2023 Jon Pretty & Propensive OÜ
EOF
  exit 0
}

fetch() {
  local group repo
  group="$1"
  repo="$2"
  git clone -q git@github.com:"$group"/"$repo" "$repo"
}

clean() {
  case "$clean" in
    1)
      echo "Cleaning $target..."
      rm -rf ".wrath/bin/$target" ".wrath/cache/$target" ".wrath/log/$target"
      ;;
    2)
      echo "Cleaning everything..."
      rm -rf .wrath/bin .wrath/cache .wrath/log .wrath/plugin
      ;;
  esac
}

checkCompiler() {
  if [ ! -d "scala" ]
  then
    if [ "$fetch" = "2" ]
    then fetch lampepfl dotty && mv dotty scala
    else
      echo "Scala compiler not found."
      echo "Try again with -F or create a symlink to a clone of the lampepfl/dotty repository."
      exit 1
    fi
  fi
  scala="$compiler"/bin/scala
  scalac="$compiler"/bin/scalac
}

mkdirs() {
  mkdir -p .wrath/bin dist .wrath/cache .wrath/log .wrath/plugins
}

setChecksum() {
  local dir
  dir="$1"
  if [ "${hashes[$dir]}" = "" ]
  then hashes[$dir]="$(md5sum "$dir"/*.scala | md5sum | cut -d' ' -f1)"
  fi
}

package() {
  local dir file
  local -a args
  local -i len
  jarFile="$1"
  dir="$2"
  len="${#dir}"
  len=$((len + 1))
  for include in "$dir"/*
  do
    file="${include:$len}"
    args+=(-C "$dir" "$file")
  done
  jar cf "${jarFile}" "${args[@]}"
}

readToml() {
  local file module IFS isMain
  local -i lineNo
  
  IFS=$'\n'
  file="$1"
  isMain="$2"
  lineNo=0
  
  if [ ! "${parsed[$file]}" = "1" ]
  then
    echo "Reading $file"
    while read -r line
    do
      lineNo=$((lineNo+1))
      case "$line" in
        '['*'/'*']')
          module="${line:1:-1}"
          ;;
        '['*']')
	  if [ "$isMain" = "1" ]
	  then main="${line:1:-1}"
	  fi
	  ;;
        '')
          ;;
        'refs = '*)
          if [ "$module" = "" ]
          then
            echo "Invalid configuration at line $lineNo:"
            echo "$line"
            exit 1
          else
            refs[$module]="${line:7}"
          fi
          ;;
        *)
          echo "Invalid configuration at line $lineNo:"
          echo "$line"
          exit 1
          ;;
      esac
    done < "$file"
    parsed[$file]="1"
  fi
}

classpath() {
  local IFS id
  local -a acc dependencies dedup
  id="$1"
  IFS=' '
  
  if [ "${lib[$id]}" = "" ]
  then
    read -ra dependencies <<< "${refs[$id]}"
    for ref in "${dependencies[@]}"
    do classpath "$ref"
    done

    for ref in "${dependencies[@]}"
    do
      acc+=(dist/"${ref//\//-}".jar)
      acc+=("${lib[$ref]}")
    done
    dedup="$(echo "${acc[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')"
    lib[$id]="$dedup"
  fi
}

build() {
  local IFS id buildModule buildComponent root src chksum
  
  id="$1"
  buildModule="$(echo "$id" | cut -d/ -f1)"
  buildComponent="$(echo "$id" | cut -d/ -f2)"
  
  if [ "$buildModule" = "$main" ]
  then root="$(realpath .)"
  else root="$(realpath "$buildModule")"
  fi
  
  IFS=' '
  
  if [ ! -d "$root" ]
  then
    if [ ! "$fetch" = "" ]
    then fetch propensive "$buildModule"
    else
      echo "Module $buildModule not found"
      echo "Try again with -f or create a symlink to $root."
      exit 1
    fi
  fi

  if [ ! -e "$root"/build.wrath ]
  then 
    echo "Build file $root/build.wrath does not exist"
    exit 1
  else
    readToml "$root"/build.wrath
  fi
  
  if [ ! "${built[$id]}" = "1" ]
  then
    if [ "${pids[$id]}" = "" ]
    then
      read -ra dependencies <<< "${refs[$id]}"
      for ref in "${dependencies[@]}"
      do
        build "$ref"
      done
      
      for ref in "${dependencies[@]}"
      do
        if [ ! "${pids[$ref]}" = "" ]
        then wait "${pids[$ref]}"
        fi
      done


      src="$root/src/$buildComponent"
      chksum="$(cat .wrath/cache/"$id" 2>/dev/null)"
      setChecksum "$src"
      if [ ! "$chksum" = "${hashes[$src]}" ]
      then
        echo "Compiling $id..."
        mkdir -p .wrath/bin/"$buildModule"/"$buildComponent"
        if [ -d "$root/res" ]
        then
          for res in "$root"/res/*
          do cp -r "$root"/res/"$res" .wrath/bin/"$buildModule"/"$buildComponent"/
          done
        fi
        classpath "$id"
        classpath="${lib[$id]// /:}"
        rm -f ".wrath/log/$buildModule/$buildComponent.log"
        compile "$buildModule" "$buildComponent" "$classpath" "$src" &
        pids[$id]="$!"
        touch .wrath/log/"$buildModule"-"$buildComponent".log
        cat .wrath/log/"$buildModule"-"$buildComponent".log
        if [ -f "$root"/res/plugin.properties ]
        then cp dist/"$buildModule"-"$buildComponent".jar .wrath/plugins/"$buildModule"-"$buildComponent".jar
        fi
      fi
    fi
  fi
}

compile() {
  local classpath buildModule buildComponent srcDir
  local -a opts
  buildModule="$1"
  buildComponent="$2"
  classpath="$3"
  srcDir="$4"

  opts=(
    -classpath "${classpath}"
    -d .wrath/bin/"$buildModule"/"$buildComponent"
    -Xmax-inlines 64
    -Xpluginsdir .wrath/plugins
    -feature
    -J-Xss1536K
    -J--enable-preview
    -new-syntax
    -source future
    -Wunused:imports
    -Yrequire-targetName
    -Ysafe-init
    -Yexplicit-nulls
    -Ycheck-all-patmat
    -language:experimental.clauseInterleaving
    -language:experimental.fewerBraces
    -language:experimental.erasedDefinitions
    -language:experimental.saferExceptions
    -language:experimental.namedTypeArguments
  )
 
  if $scalac "${opts[@]}" "$srcDir"/*.scala > .wrath/log/"$buildModule"-"$buildComponent".log 2>&1
  then
    mkdir -p .wrath/cache/"$buildModule"
    echo "${hashes[$src]}" > .wrath/cache/"$id"
    built[$id]="1"
    echo "Compiled $id"
    cat ".wrath/log/$buildModule-$buildComponent.log"
    package dist/"$buildModule"-"$buildComponent".jar .wrath/bin/"$buildModule"/"$buildComponent"
  else
    cat ".wrath/log/$buildModule-$buildComponent.log"
    exit 1
  fi
}

parseOpts() {
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      -r|--run)
        nonempty "$@"
        run="$2"
        shift 2 ;;
      -j|--jdk)
        nonempty "$@"
        export JAVA_HOME="$2"
        shift 2 ;;
      -g|--group)
        group="$2"
        shift 2 ;;
      -h|--help)
        showHelp
        ;;
      -s|--scala)
        nonempty "$@"
        compiler="$2"
        shift 2 ;;
      -c|--clean)
        clean="1"
        shift 1 ;;
      -C|--deep-clean)
        clean="2"
        shift 1 ;;
      -f|--fetch)
        fetch="1"
        shift 1 ;;
      -F|--fetch-alll)
        fetch="2"
        shift 1 ;;
      -t|--target)
        target="$2"
        shift 2 ;;
      -*)
        echo "Unrecognized option: '$1'"
        exit 1 ;;
      *)
        echo "Unrecognized parameter: '$1"
        exit 1 ;;
    esac
  done
}

checkTarget() {
  if [[ "$target" = "" ]]
  then
    echo "A build target is required"
    exit 1
  fi
}

parseOpts "$@"


clean
checkCompiler
mkdirs

module="$(echo "$target" | cut -d/ -f1)"
component="$(echo "$target" | cut -d/ -f2)"

readToml build.wrath 1

build "$target"
wait
if [ ! "$run" = "" ]
then
  classpath "$target"
  classpath="${lib[$target]// /:}"

  "$scala" -classpath "${classpath}"dist/"$module"-"$component".jar "$run"
fi
