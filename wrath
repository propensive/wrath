#!/bin/bash
#
#   Wrath, version 0.1.0. Copyright 2023 Jon Pretty, Propensive OÜ.
#
#   The primary distribution site is: https://propensive.com/
#
#   Licensed under the Apache License, Version 2.0 (the "License"); you may not use this
#   file except in compliance with the License. You may obtain a copy of the License at
#
#   http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software distributed under the
#   License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
#   either express or implied. See the License for the specific language governing permissions
#   and limitations under the License.
#

declare -g -A refs built parsed pids hashes lib
declare -g run fetch scala scalac compiler repl esc

esc=$'\e'
compiler="$(realpath scala)"

nonempty() {
  if [ "$2" = "" ]
  then
    echo "The option $1 requires a parameter."
    exit 1
  fi
}

showHelp() {
  cat << EOF
Usage: wrath [options]
Builds a project with Wrath.

Options:
  -c, --clean              clean the target project
  -C, --deep-clean         clean all targets
  -f, --fetch              automatically fetch missing dependencies
  -F, --fetch-all          automatically fetch missing dependencies and compiler
  -g, --group <group>      use the default group <group>
  -h, --help               show this help message
  -j, --jdk <path>         use the JDK with home directory at <path>
  -r, --repl               start the REPL
  -t, --target <target>    target to compile
  -x, --exec <class>       run the main class <class>

Examples:
  wrath -t rudiments/core
  wrath -C -g propensive -t rudiments/core -F

© Copyright 2023 Jon Pretty & Propensive OÜ
EOF
  exit 0
}

fetch() {
  local group repo
  group="$1"
  repo="$2"
  git clone -q git@github.com:"$group"/"$repo" "$repo"
}

clean() {
  case "$clean" in
    1)
      message "$module" "$component" "Cleaning"
      rm -rf ".wrath/bin/$target" ".wrath/cache/$target" ".wrath/log/$target"
      ;;
    2)
      message "$module" "$component" "Cleaning everything"
      rm -rf .wrath/bin .wrath/cache .wrath/log .wrath/plugin
      ;;
  esac
}

checkCompiler() {
  if [ ! -d "scala" ]
  then
    if [ "$fetch" = "2" ]
    then fetch lampepfl dotty && mv dotty scala
    else
      echo "Scala compiler not found."
      echo "Try again with -F or create a symlink to a clone of the lampepfl/dotty repository."
      exit 1
    fi
  fi
  scala="$compiler"/bin/scala
  scalac="$compiler"/bin/scalac
}

mkdirs() {
  mkdir -p .wrath/bin dist .wrath/cache .wrath/log .wrath/plugins
}

setChecksum() {
  local dir
  dir="$1"
  if [ "${hashes[$dir]}" = "" ]
  then hashes[$dir]="$(md5sum "$dir"/*.scala | md5sum | cut -d' ' -f1)"
  fi
}

package() {
  local dir file
  local -a args
  local -i len
  jarFile="$1"
  dir="$2"
  len="${#dir}"
  len=$((len + 1))
  for include in "$dir"/*
  do
    file="${include:$len}"
    args+=(-C "$dir" "$file")
  done
  jar cf "${jarFile}" "${args[@]}"
}

readToml() {
  local file dir module IFS isMain buildModule buildComponent
  local -i lineNo
  
  IFS=$'\n'
  buildModule="$1"
  buildComponent="$2"
  file="$3"
  dir="$(dirname "$(realpath --relative-to="$PWD" "$file")")"
  isMain="$4"
  lineNo=0
  
  if [ ! "${parsed[$file]}" = "1" ]
  then
    message "$buildModule" "$buildComponent" "Reading buildfile in ${dir}/"
    while read -r line
    do
      lineNo=$((lineNo+1))
      case "$line" in
        '['*'/'*']')
          module="${line:1:-1}"
          ;;
        '['*']')
	  if [ "$isMain" = "1" ]
	  then main="${line:1:-1}"
	  fi
	  ;;
        '')
          ;;
        'refs = '*)
          if [ "$module" = "" ]
          then
            message "$buildModule" "$buildComponent" "Invalid configuration at line $lineNo:"
            message "$buildModule" "$buildComponent" "$line"
            exit 1
          else
            refs[$module]="${line:7}"
          fi
          ;;
        *)
          message "$buildModule" "$buildComponent" "Invalid configuration at line $lineNo:"
          message "$buildModule" "$buildComponent" "$line"
          exit 1
          ;;
      esac
    done < "$file"
    parsed[$file]="1"
  fi
}

classpath() {
  local IFS id
  local -a acc dependencies dedup
  id="$1"
  IFS=' '
  
  if [ "${lib[$id]}" = "" ]
  then
    read -ra dependencies <<< "${refs[$id]}"
    for ref in "${dependencies[@]}"
    do classpath "$ref"
    done

    for ref in "${dependencies[@]}"
    do
      acc+=(dist/"${ref//\//-}".jar)
      acc+=("${lib[$ref]}")
    done
    dedup="$(echo "${acc[@]}" | tr ' ' '\n' | sort -u | tr '\n' ' ')"
    lib[$id]="$dedup"
  fi
}

build() {
  local IFS id buildModule buildComponent root src chksum
  
  id="$1"
  buildModule="$(echo "$id" | cut -d/ -f1)"
  buildComponent="$(echo "$id" | cut -d/ -f2)"
  
  if [ "$buildModule" = "$main" ]
  then root="$(realpath .)"
  else root="$(realpath "$buildModule")"
  fi
  
  IFS=' '
  
  if [ ! -d "$root" ]
  then
    if [ ! "$fetch" = "" ]
    then
      message "$buildModule" "$buildComponent" "Cloning Git repository"
      fetch propensive "$buildModule"
    else
      message "$buildModule" "$buildComponent" "Module $buildModule not found"
      message "$buildModule" "$buildComponent" "Try again with -f or create a symlink to $root."
      exit 1
    fi
  fi

  if [ ! -e "$root"/build.wrath ]
  then 
    message "$buildModule" "$buildComponent" "Build file $root/build.wrath does not exist"
    exit 1
  else
    readToml "$buildModule" "$buildComponent" "$root"/build.wrath
  fi
  
  if [ ! "${built[$id]}" = "1" ]
  then
    if [ "${pids[$id]}" = "" ]
    then
      read -ra dependencies <<< "${refs[$id]}"
      for ref in "${dependencies[@]}"
      do
        build "$ref"
      done
      
      for ref in "${dependencies[@]}"
      do
        if [ ! "${pids[$ref]}" = "" ]
        then wait "${pids[$ref]}"
        fi
      done


      src="$root/src/$buildComponent"
      chksum="$(cat .wrath/cache/"$id" 2>/dev/null)"
      setChecksum "$src"
      if [ ! "$chksum" = "${hashes[$src]}" ]
      then
        message "$buildModule" "$buildComponent" "Compiling with Scala"
        mkdir -p .wrath/bin/"$buildModule"/"$buildComponent"
        if [ -d "$root/res" ]
        then
          for res in "$root"/res/*
          do cp -r "$res" .wrath/bin/"$buildModule"/"$buildComponent"/
          done
        fi
        classpath "$id"
        classpath="${lib[$id]// /:}"
        rm -f ".wrath/log/$buildModule/$buildComponent.log"
        compile "$buildModule" "$buildComponent" "$classpath" "$src"
        pids[$id]="$!"
        
	if [ -f "$root"/res/plugin.properties ]
        then cp dist/"$buildModule"-"$buildComponent".jar .wrath/plugins/"$buildModule"-"$buildComponent".jar
        fi
      fi
    fi
  fi
}

compile() {
  local classpath buildModule buildComponent srcDir
  local -i pageWidth
  local -a opts
  buildModule="$1"
  buildComponent="$2"
  classpath="$3"
  pageWidth=$((COLUMNS - 21))
  srcDir="$4"

  opts=(
    -classpath "$classpath"
    -d .wrath/bin/"$buildModule"/"$buildComponent"
    -Xmax-inlines 64
    -Xpluginsdir .wrath/plugins
    -feature
    -pagewidth "$pageWidth"
    -J-Xss1536K
    -J--enable-preview
    -new-syntax
    -source future
    -Wunused:imports
    -Yrequire-targetName
    -Ysafe-init
    -Yexplicit-nulls
    -Ycheck-all-patmat
    -language:experimental.clauseInterleaving
    -language:experimental.fewerBraces
    -language:experimental.erasedDefinitions
    -language:experimental.saferExceptions
    -language:experimental.namedTypeArguments
  )

  rm -f .wrath/log/"$buildModule"-"$buildComponent".log
  touch ".wrath/log/$buildModule-$buildComponent.log"
  if $scalac "${opts[@]}" "$srcDir"/*.scala > .wrath/log/"$buildModule"-"$buildComponent".log 2>&1
  then
    mkdir -p .wrath/cache/"$buildModule"
    echo "${hashes[$src]}" > .wrath/cache/"$id"
    built[$id]="1"
    message "$buildModule" "$buildComponent" "Compiled $id"
    
    while read -r line
    do message "$buildModule" "$buildComponent" "$line"
    done < .wrath/log/"$buildModule"-"$buildComponent".log

    package dist/"$buildModule"-"$buildComponent".jar .wrath/bin/"$buildModule"/"$buildComponent"
  else
    message "$buildModule" "$buildComponent" "Compilation failed"
    
    while read -r line
    do message "$buildModule" "$buildComponent" "$line"
    done < .wrath/log/"$buildModule"-"$buildComponent".log
    
    exit 1
  fi
}

message() {
  local module component text prefix
  module="$1"
  component="$2"
  text="$3"
  prefix="${esc}[0;36m$module${esc}[2;37m/${esc}[1;34m$component${esc}[2;37m:${esc}[0m"
  printf "%52s %s\n" "$prefix" "$text"
}

parseOpts() {
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      -c|--clean)
        clean="1"
        shift 1 ;;
      -C|--deep-clean)
        clean="2"
        shift 1 ;;
      -f|--fetch)
        fetch="1"
        shift 1 ;;
      -F|--fetch-alll)
        fetch="2"
        shift 1 ;;
      -g|--group)
        group="$2"
        shift 2 ;;
      -h|--help)
        showHelp
        ;;
      -j|--jdk)
        nonempty "$@"
        export JAVA_HOME="$2"
        shift 2 ;;
      -r|--repl)
        repl="1"
	shift ;;
      -s|--scala)
        nonempty "$@"
        compiler="$2"
        shift 2 ;;
      -t|--target)
        target="$2"
        shift 2 ;;
      -x|--exec)
        nonempty "$@"
        run="$2"
        shift 2 ;;
      -*)
        echo "Unrecognized option: '$1'"
        exit 1 ;;
      *)
        echo "Unrecognized parameter: '$1"
        exit 1 ;;
    esac
  done
}

checkTarget() {
  if [[ "$target" = "" ]]
  then
    echo "A build target is required"
    exit 1
  fi
}

parseOpts "$@"

module="$(echo "$target" | cut -d/ -f1)"
component="$(echo "$target" | cut -d/ -f2)"

readToml "$module" "$component" "build.wrath" 1

clean
checkCompiler
mkdirs


build "$target"
wait
if [ ! "$run" = "" ]
then
  classpath "$target"
  classpath="${lib[$target]// /:}"
  "$scala" -classpath "${classpath}"dist/"$module"-"$component".jar "$run"
fi

if [ "$repl" = "1" ]
then
  classpath "$target"
  classpath="${lib[$target]// /:}"
  "$scala" -classpath "${classpath}"dist/"$module"-"$component".jar
fi
